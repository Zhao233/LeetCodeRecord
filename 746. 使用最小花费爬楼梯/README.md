# 解题思路说明

## 题目地址
[使用最小花费爬楼梯 (minCostClimbingStairs)](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)

## 解题过程
1. 分析题意
2. 分析最优子结构
3. 分析边界
4. 描述状态转移方程
5. 代码实现
    * 递归方法
    * 动态规划方法


### 样例数据: 
nums

下标| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10
 -- | -- | -- | -- |-- |-- |-- |-- |-- |-- |-- |-- |-- |--
数据  | 1 | 100 | 1 | 1 | 1 | 100 | 1 | 1 | 100 | 1 | 0

### 

### 1.分析题意
这道题和爬楼梯有相似的地方,不同的是每一阶台阶都有"消耗".题目给我们一个数组,代表每一阶台阶的消耗值.  
题目要求我们求出爬到楼顶时最小的体力消耗值,但是数组最后一个数字实际上是最后一个台阶,而并非是楼顶(这里可能是我的思维出错,后面想清楚了会再更新),所以在解题时,再数组后面加一个0,代表顶楼.  

### 2.分析最优子结构
假设我们现在已经到达了楼顶nums[10],要想得到最小的消耗,那就需要在到达顶楼前的一步就是最小的消耗,到达楼顶前的一步一共有两种走法,一个是走一步: 9->10,另一种是走两步:8->10;为得到最优解,我们需要比较这两个走法的最小值.     
我们设opt(i)为当前到第i个台阶时的最优解(最小的消耗),到达楼顶时:opt(10) = min{ opt(9) , opt(8) }+nums(10)

### 3.分析边界
题目已经告诉我们,第一步可以选择第一阶或者第二阶,所以程序的边界就是opt(0) = nums(0), opt(1) = nums(1)

### 4.描述状态转移方程

1. opt(0) = nums(0)
2. opt(1) = nums(1)
2. opt(i) = min{ opt(i-1), opt(i-2) }+nums(i)

### 5.代码实现
[递归实现](https://github.com/Zhao233/LeetCodeRecord/blob/master/746.%20%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/scala_recursion.scala)            
[动态规划实现](https://github.com/Zhao233/LeetCodeRecord/blob/master/746.%20%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/scala_dp.scala) 

### 举例说明

## 注意
需要加上当前的消耗

## 其它
